/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.Shanghai_Lunara.helixsaga_operator.pkg.apis.helixsaga.v1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1";

// HelixSaga describes a HelixSaga resource
message HelixSaga {
  // ObjectMeta contains the metadata for the particular object, including
  // things like...
  //  - name
  //  - namespace
  //  - self link
  //  - labels
  //  - ... etc ...
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec is the custom resource spec
  optional HelixSagaSpec spec = 2;
}

message HelixSagaApp {
  optional HelixSagaAppSpec spec = 1;

  optional HelixSagaAppStatus status = 2;
}

// HelixSagaAppSpec is the sub spec for a HelixSaga resource
message HelixSagaAppSpec {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  optional string name = 1;

  // Replicas is the number of desired replicas.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  // +optional
  optional int32 replicas = 2;

  // Docker image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  // +optional
  optional string image = 3;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 4;

  // List of environment variables to set in the container.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.EnvVar env = 5;

  // Resources represents the minimum resources the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  // +optional
  optional k8s.io.api.core.v1.ResourceRequirements resources = 6;

  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=mountPath
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 7;

  // Entrypoint array. Not executed within a shell.
  // The docker image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string command = 8;

  // Arguments to the entrypoint.
  // The docker image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string args = 9;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated k8s.io.api.core.v1.ContainerPort containerPorts = 10;

  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated k8s.io.api.core.v1.ServicePort servicePorts = 11;

  // The type of services
  optional string serviceType = 12;

  // The path of the nas disk which was mounted on the machine
  optional string volumePath = 13;

  // Watch policy for the present app.
  // One of Auto, Manual.
  // Default to Manual.
  optional string watchPolicy = 14;
}

// HelixSagaAppStatus is the sub status for a HelixSaga resource
message HelixSagaAppStatus {
  // observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
  // StatefulSet's generation, which is updated on mutation by the API Server.
  // +optional
  optional int64 observedGeneration = 1;

  // replicas is the number of Pods created by the StatefulSet controller.
  optional int32 replicas = 2;

  // readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.
  optional int32 readyReplicas = 3;

  // currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by currentRevision.
  optional int32 currentReplicas = 4;

  // updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by updateRevision.
  optional int32 updatedReplicas = 5;

  // currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
  // sequence [0,currentReplicas).
  optional string currentRevision = 6;

  // updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
  // [replicas-updatedReplicas,replicas)
  optional string updateRevision = 7;

  // collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
  // uses this field as a collision avoidance mechanism when it needs to create the name for the
  // newest ControllerRevision.
  // +optional
  optional int32 collisionCount = 9;
}

message HelixSagaConfigMap {
  optional k8s.io.api.core.v1.Volume volume = 1;

  optional k8s.io.api.core.v1.VolumeMount volumeMount = 2;
}

// HelixSagaList is a list of HelixSaga resources
message HelixSagaList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated HelixSaga items = 2;
}

// HelixSagaSpec is the spec for a HelixSaga resource
message HelixSagaSpec {
  optional HelixSagaConfigMap configMap = 1;

  repeated HelixSagaApp applications = 2;
}

